Backport of:

From 89c2720298f875ac80777da2da88a64859775898 Mon Sep 17 00:00:00 2001
From: Matt Caswell <matt@openssl.org>
Date: Fri, 10 Apr 2015 17:25:27 +0100
Subject: [PATCH] Check for ClientHello message overruns

The ClientHello processing is insufficiently rigorous in its checks to make
sure that we don't read past the end of the message. This does not have
security implications due to the size of the underlying buffer - but still
needs to be fixed.

With thanks to Qinghao Tang for reporting this issue.

Reviewed-by: Rich Salz <rsalz@openssl.org>
(cherry picked from commit c9642eb1ff79a30e2c7632ef8267cc34cc2b0d79)
---
 ssl/s3_srvr.c | 42 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 41 insertions(+), 1 deletion(-)

Index: openssl-1.0.1f/ssl/s3_srvr.c
===================================================================
--- openssl-1.0.1f.orig/ssl/s3_srvr.c	2017-01-30 11:07:41.467312664 -0500
+++ openssl-1.0.1f/ssl/s3_srvr.c	2017-01-30 11:11:59.810656978 -0500
@@ -945,6 +945,16 @@
 	s->first_packet=0;
 	d=p=(unsigned char *)s->init_msg;
 
+	/*
+	 * 2 bytes for client version, SSL3_RANDOM_SIZE bytes for random, 1 byte
+	 * for session id length
+	 */
+	if (n < 2 + SSL3_RANDOM_SIZE + 1) {
+		al = SSL_AD_DECODE_ERROR;
+		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
+		goto f_err;
+	}
+
 	/* use version from inside client hello, not from record header
 	 * (may differ: see RFC 2246, Appendix E, second paragraph) */
 	s->client_version=(((int)p[0])<<8)|(int)p[1];
@@ -973,6 +983,12 @@
 		unsigned int session_length, cookie_length;
 		
 		session_length = *(p + SSL3_RANDOM_SIZE);
+
+		if (p + SSL3_RANDOM_SIZE + session_length + 1 >= d + n) {
+			al = SSL_AD_DECODE_ERROR;
+			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
+			goto f_err;
+		}
 		cookie_length = *(p + SSL3_RANDOM_SIZE + session_length + 1);
 
 		if (cookie_length == 0)
@@ -986,6 +1002,12 @@
 	/* get the session-id */
 	j= *(p++);
 
+	if (p + j > d + n) {
+		al = SSL_AD_DECODE_ERROR;
+		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
+		goto f_err;
+	}
+
 	s->hit=0;
 	/* Versions before 0.9.7 always allow clients to resume sessions in renegotiation.
 	 * 0.9.7 and later allow this by default, but optionally ignore resumption requests
@@ -1024,8 +1046,19 @@
 	if (s->version == DTLS1_VERSION || s->version == DTLS1_BAD_VER)
 		{
 		/* cookie stuff */
+		if (p + 1 > d + n) {
+			al = SSL_AD_DECODE_ERROR;
+			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
+			goto f_err;
+		}
 		cookie_len = *(p++);
 
+		if (p + cookie_len > d + n) {
+			al = SSL_AD_DECODE_ERROR;
+			SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
+			goto f_err;
+		}
+
 		/* 
 		 * The ClientHello may contain a cookie even if the
 		 * HelloVerify message has not been sent--make sure that it
@@ -1072,6 +1105,11 @@
 		p += cookie_len;
 		}
 
+	if (p + 2 > d + n) {
+		al = SSL_AD_DECODE_ERROR;
+		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO, SSL_R_LENGTH_TOO_SHORT);
+		goto f_err;
+	}
 	n2s(p,i);
 	if ((i == 0) && (j != 0))
 		{
@@ -1080,7 +1118,9 @@
 		SSLerr(SSL_F_SSL3_GET_CLIENT_HELLO,SSL_R_NO_CIPHERS_SPECIFIED);
 		goto f_err;
 		}
-	if ((p+i) >= (d+n))
+
+		/* i bytes of cipher data + 1 byte for compression length later */
+		if ((p + i + 1) > (d + n))
 		{
 		/* not enough data */
 		al=SSL_AD_DECODE_ERROR;
