From fa75569758298e2930c78989b516cac937118acc Mon Sep 17 00:00:00 2001
From: Matt Caswell <matt@openssl.org>
Date: Tue, 5 Jul 2016 11:46:26 +0100
Subject: [PATCH] Fix DTLS unprocessed records bug

During a DTLS handshake we may get records destined for the next epoch
arrive before we have processed the CCS. In that case we can't decrypt or
verify the record yet, so we buffer it for later use. When we do receive
the CCS we work through the queue of unprocessed records and process them.

Unfortunately the act of processing wipes out any existing packet data
that we were still working through. This includes any records from the new
epoch that were in the same packet as the CCS. We should only process the
buffered records if we've not got any data left.

Reviewed-by: Richard Levitte <levitte@openssl.org>
---
 ssl/d1_pkt.c | 23 +++++++++++++++++++++--
 1 file changed, 21 insertions(+), 2 deletions(-)

Index: openssl-1.0.1f/ssl/d1_pkt.c
===================================================================
--- openssl-1.0.1f.orig/ssl/d1_pkt.c	2016-09-22 09:19:07.211419234 -0400
+++ openssl-1.0.1f/ssl/d1_pkt.c	2016-09-22 09:22:36.033951001 -0400
@@ -303,6 +303,7 @@
 dtls1_process_buffered_records(SSL *s)
     {
     pitem *item;
+    SSL3_BUFFER *rb;
     
     item = pqueue_peek(s->d1->unprocessed_rcds.q);
     if (item)
@@ -311,6 +312,18 @@
         if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)
             return(1);  /* Nothing to do. */
         
+        rb = &s->s3->rbuf;
+
+        if (rb->left > 0) {
+            /*
+             * We've still got data from the current packet to read. There could
+             * be a record from the new epoch in it - so don't overwrite it
+             * with the unprocessed records yet (we'll do it when we've
+             * finished reading the current packet).
+             */
+            return 1;
+        }
+
         /* Process all the records. */
         while (pqueue_peek(s->d1->unprocessed_rcds.q))
             {
@@ -564,6 +577,7 @@
 
 	rr= &(s->s3->rrec);
 
+again:
 	/* The epoch may have changed.  If so, process all the
 	 * pending records.  This is a non-blocking operation. */
 	if(dtls1_process_buffered_records(s)<0)
@@ -574,7 +588,6 @@
 		return 1;
 
 	/* get something from the wire */
-again:
 	/* check if we have the header */
 	if (	(s->rstate != SSL_ST_READ_BODY) ||
 		(s->packet_length < DTLS1_RT_HEADER_LENGTH)) 
@@ -1810,8 +1823,13 @@
     if (rr->epoch == s->d1->r_epoch)
         return &s->d1->bitmap;
 
-    /* Only HM and ALERT messages can be from the next epoch */
+    /*
+     * Only HM and ALERT messages can be from the next epoch and only if we
+     * have already processed all of the unprocessed records from the last
+     * epoch
+     */
     else if (rr->epoch == (unsigned long)(s->d1->r_epoch + 1) &&
+        s->d1->unprocessed_rcds.epoch != s->d1->r_epoch &&
         (rr->type == SSL3_RT_HANDSHAKE ||
             rr->type == SSL3_RT_ALERT))
         {
