Backport of:

From 1a3701f4fe0530a40ec073cd78d02cfcc26c0f8e Mon Sep 17 00:00:00 2001
From: Matt Caswell <matt@openssl.org>
Date: Mon, 27 Apr 2015 11:07:06 +0100
Subject: [PATCH] Sanity check EVP_CTRL_AEAD_TLS_AAD

The various implementations of EVP_CTRL_AEAD_TLS_AAD expect a buffer of at
least 13 bytes long. Add sanity checks to ensure that the length is at
least that. Also add a new constant (EVP_AEAD_TLS1_AAD_LEN) to evp.h to
represent this length. Thanks to Kevin Wojtysiak (Int3 Solutions) and
Paramjot Oberoi (Int3 Solutions) for reporting this issue.

Reviewed-by: Andy Polyakov <appro@openssl.org>
(cherry picked from commit c8269881093324b881b81472be037055571f73f3)

Conflicts:
	ssl/record/ssl3_record.c
---
 apps/speed.c                       | 5 +++--
 crypto/evp/e_aes.c                 | 2 +-
 crypto/evp/e_aes_cbc_hmac_sha1.c   | 9 ++++++---
 crypto/evp/e_aes_cbc_hmac_sha256.c | 7 +++++--
 crypto/evp/e_rc4_hmac_md5.c        | 7 ++++++-
 crypto/evp/evp.h                   | 3 +++
 ssl/t1_enc.c                       | 7 +++++--
 7 files changed, 29 insertions(+), 11 deletions(-)

Index: openssl-1.0.1f/crypto/evp/e_aes.c
===================================================================
--- openssl-1.0.1f.orig/crypto/evp/e_aes.c	2017-01-30 12:51:26.025768464 -0500
+++ openssl-1.0.1f/crypto/evp/e_aes.c	2017-01-30 12:53:31.351405247 -0500
@@ -791,7 +791,7 @@
 
 	case EVP_CTRL_AEAD_TLS1_AAD:
 		/* Save the AAD for later use */
-		if (arg != 13)
+		if (arg != EVP_AEAD_TLS1_AAD_LEN)
 			return 0;
 		memcpy(c->buf, ptr, arg);
 		gctx->tls_aad_len = arg;
Index: openssl-1.0.1f/crypto/evp/e_aes_cbc_hmac_sha1.c
===================================================================
--- openssl-1.0.1f.orig/crypto/evp/e_aes_cbc_hmac_sha1.c	2017-01-30 12:51:26.025768464 -0500
+++ openssl-1.0.1f/crypto/evp/e_aes_cbc_hmac_sha1.c	2017-01-30 12:54:26.100120138 -0500
@@ -492,7 +492,12 @@
 	case EVP_CTRL_AEAD_TLS1_AAD:
 		{
 		unsigned char *p=ptr;
-		unsigned int   len=p[arg-2]<<8|p[arg-1];
+		unsigned int len;
+
+		if (arg != EVP_AEAD_TLS1_AAD_LEN)
+			return -1;
+
+		len = p[arg - 2] << 8 | p[arg - 1];
 
 		if (ctx->encrypt)
 			{
@@ -510,7 +515,6 @@
 			}
 		else
 			{
-			if (arg>13) arg = 13;
 			memcpy(key->aux.tls_aad,ptr,arg);
 			key->payload_length = arg;
 
Index: openssl-1.0.1f/crypto/evp/e_rc4_hmac_md5.c
===================================================================
--- openssl-1.0.1f.orig/crypto/evp/e_rc4_hmac_md5.c	2017-01-30 12:51:26.025768464 -0500
+++ openssl-1.0.1f/crypto/evp/e_rc4_hmac_md5.c	2017-01-30 12:55:01.004571988 -0500
@@ -253,7 +253,12 @@
 	case EVP_CTRL_AEAD_TLS1_AAD:
 		{
 		unsigned char *p=ptr;
-		unsigned int   len=p[arg-2]<<8|p[arg-1];
+		unsigned int len;
+
+		if (arg != EVP_AEAD_TLS1_AAD_LEN)
+			return -1;
+
+		len = p[arg - 2] << 8 | p[arg - 1];
 
 		if (!ctx->encrypt)
 			{
Index: openssl-1.0.1f/crypto/evp/evp.h
===================================================================
--- openssl-1.0.1f.orig/crypto/evp/evp.h	2017-01-30 12:51:26.025768464 -0500
+++ openssl-1.0.1f/crypto/evp/evp.h	2017-01-30 12:56:24.225632169 -0500
@@ -394,6 +394,9 @@
 /* Set the GCM invocation field, decrypt only */
 #define		EVP_CTRL_GCM_SET_IV_INV		0x18
 
+/* RFC 5246 defines additional data to be 13 bytes in length */
+# define         EVP_AEAD_TLS1_AAD_LEN           13
+
 /* GCM TLS constants */
 /* Length of fixed part of IV derived from PRF */
 #define EVP_GCM_TLS_FIXED_IV_LEN			4
Index: openssl-1.0.1f/ssl/t1_enc.c
===================================================================
--- openssl-1.0.1f.orig/ssl/t1_enc.c	2017-01-30 12:51:26.025768464 -0500
+++ openssl-1.0.1f/ssl/t1_enc.c	2017-01-30 12:57:52.862762269 -0500
@@ -756,7 +756,7 @@
 
 		if (EVP_CIPHER_flags(ds->cipher)&EVP_CIPH_FLAG_AEAD_CIPHER)
 			{
-			unsigned char buf[13],*seq;
+			unsigned char buf[EVP_AEAD_TLS1_AAD_LEN], *seq;
 
 			seq = send?s->s3->write_sequence:s->s3->read_sequence;
 
@@ -783,7 +783,10 @@
 			buf[10]=(unsigned char)(s->version);
 			buf[11]=rec->length>>8;
 			buf[12]=rec->length&0xff;
-			pad=EVP_CIPHER_CTX_ctrl(ds,EVP_CTRL_AEAD_TLS1_AAD,13,buf);
+			pad = EVP_CIPHER_CTX_ctrl(ds, EVP_CTRL_AEAD_TLS1_AAD,
+						  EVP_AEAD_TLS1_AAD_LEN, buf);
+			if (pad <= 0)
+				return -1;
 			if (send)
 				{
 				l+=pad;
